#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <RTClib.h>
#include <AccelStepper.h>
#include <time.h>

// -------------------------------------------
// WIFI + MQTT SETTINGS
// -------------------------------------------

// Insert your WiFi credentials below
const char* WIFI_SSID = "YOUR_WIFI_SSID";
const char* WIFI_PASS = "YOUR_WIFI_PASSWORD";

// Insert your MQTT broker settings below
const char* MQTT_BROKER = "YOUR_MQTT_BROKER_URL";
const int   MQTT_PORT   = 8883;  // Change if needed
const char* MQTT_USER = "YOUR_MQTT_USERNAME";
const char* MQTT_PASS = "YOUR_MQTT_PASSWORD";

// TOPICS
// Insert your MQTT topics below (customize as needed)
const char* TOPIC_ALERT       = "YOUR_TOPIC_ALERT";        // ESP32 → AI
const char* TOPIC_AI_RESULT   = "YOUR_TOPIC_AI_RESULT";    // AI → ESP32
const char* TOPIC_SET_TIME    = "YOUR_TOPIC_SET_TIME";     // Dashboard → ESP32

WiFiClientSecure wifiClient;    
PubSubClient mqttClient(wifiClient);

// -------------------------------------------
// I2C / RTC / LCD
// -------------------------------------------
LiquidCrystal_I2C lcd(0x27, 16, 2);
RTC_DS3231 rtc;

// -------------------------------------------
// STEPPER (28BYJ-48 + ULN2003)
// -------------------------------------------
#define IN1 16
#define IN2 17
#define IN3 18
#define IN4 19
AccelStepper stepper(AccelStepper::FULL4WIRE, IN1, IN3, IN2, IN4);

// -------------------------------------------
//HOME SLOT RECALIBRATE
// -------------------------------------------
#define TOTAL_SLOTS 8      // including empty hole
#define MED_SLOTS   7      // actual medicine slots
int slotIndex = 0;         // 0 = HOME (empty hole)

bool returningHome = false;

// -------------------------------------------
// DISPENSE / MISS TRACKING (FOR REFILL LOGIC)
// -------------------------------------------
int dispensedCount = 0;
int missedCount = 0;

// -------------------------------------------
#define BUZZER_PIN 26

bool alarmActive = false;
bool motorMoving = false;
bool cycleCompleted = false;

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 8 * 3600;   // GMT+8 (Malaysia)
const int   daylightOffset_sec = 0;

// Slots / step movement
int currentSlot = 0;
const int SLOTS = 8;
const long STEPS_PER_SLOT = 256;
int physicalSlotIndex = 0;   // counts actual motor rotations

// --------------------
// TIMER VARIABLES
// --------------------
int schedHour = -1;
int schedMinute = -1;
int schedSecond = -1;

bool scheduleActive = false;
bool intervalMode = false;
bool aiTriggeredByTimer = false;
bool homingPending = false;
unsigned long homingStartTime = 0;

const unsigned long HOME_DELAY_MS = 7000; // 7 seconds grace
unsigned long lastIntervalTime = 0;

// -------------------------------------------

String lcdLine1 = "";
String lcdLine2 = "";

bool lcdOverride = false;
unsigned long lcdOverrideStart = 0;
const unsigned long LCD_OVERRIDE_DURATION = 4000; // 4 seconds

void showLCDMessage(String line1, String line2) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(line1);
  lcd.setCursor(0, 1);
  lcd.print(line2);

  lcdLine1 = line1;
  lcdLine2 = line2;
  lcdOverride = true;
  lcdOverrideStart = millis();
}

// LCD CENTERED PRINT
void printCentered(uint8_t row, const char* text) {
  int len = strlen(text);
  if (len > 16) len = 16;
  int pad = (16 - len) / 2;

  lcd.setCursor(0, row);
  for (int i = 0; i < pad; i++) lcd.print(' ');
  for (int i = 0; i < len; i++) lcd.print(text[i]);
  for (int i = pad + len; i < 16; i++) lcd.print(' ');
}

void checkRefillStatus() {
  if (dispensedCount == 0) {
    Serial.println("----- CYCLE SUMMARY -----");
    Serial.print("Dispensed: ");
    Serial.println(dispensedCount);
    Serial.print("Missed: ");
    Serial.println(missedCount);
    Serial.println("-------------------------");
    // No pills taken → no refill
    return;
  }
  if (dispensedCount >= (MED_SLOTS - 2) && dispensedCount < MED_SLOTS) {
    mqttClient.publish(
      TOPIC_ALERT,
      "REFILL_SOON"
    );
  }

  if (dispensedCount == MED_SLOTS) {
    mqttClient.publish(
      TOPIC_ALERT,
      "REFILL_REQUIRED"
    );
  }
}

// -------------------------------------------
// MQTT CALLBACK (AI + SET_TIME)
// -------------------------------------------
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  
  String msg = "";
  for (int i = 0; i < length; i++) {
    msg += (char)payload[i];
  }

  Serial.print("MQTT Received [");
  Serial.print(topic);
  Serial.print("]: ");
  Serial.println(msg);


  // ===== FORCE DISPENSE (RECOVERY ONLY) =====
  if (String(topic) == "YOUR_TOPIC_MANUAL" && msg == "FORCE_DISPENSE") {
    Serial.println("FORCE DISPENSE REQUESTED");

    if (motorMoving && stepper.distanceToGo() != 0) {
      Serial.println("FORCE DISPENSE: Resuming motor");
      // AccelStepper continues automatically via stepper.run()
    } else {
      Serial.println("FORCE DISPENSE IGNORED: Motor not stalled");
    }
    return;
  }


  // ===== PRESENCE CHECK ONLY =====
  if (String(topic) == TOPIC_ALERT && msg == "PRESENCE_CHECK") {
    Serial.println("Presence check triggered");

    // Ask AI to scan, no alarm, no motor
    mqttClient.publish("YOUR_TOPIC_STATUS", "PRESENCE_CHECK_TRIGGERED");
    mqttClient.publish(TOPIC_ALERT, "CHECK_PRESENCE");
    return;
  }


  // ===== AI RESULT HANDLER =====
  if (String(topic) == TOPIC_AI_RESULT) {

    Serial.print("AI Result: ");
    Serial.println(msg);
    digitalWrite(BUZZER_PIN, LOW);
    alarmActive = false;
    
    // --- TIMER PATH ---
    if (aiTriggeredByTimer) {

      aiTriggeredByTimer = false;   // reset immediately

      if (msg == "PRESENT") {
        Serial.println("Timer + AI PRESENT → DISPENSING");
        
        stepper.move(STEPS_PER_SLOT);
        motorMoving = true;
        physicalSlotIndex++;
        mqttClient.publish("YOUR_TOPIC_STATUS", ("DISPENSED," + String(currentSlot)).c_str());
        dispensedCount++;

        if (!cycleCompleted && (dispensedCount + missedCount >= MED_SLOTS)) {
          cycleCompleted = true;
        }
      } else {
        Serial.println("Timer + AI NOT PRESENT → MISSED");
        mqttClient.publish("YOUR_TOPIC_STATUS", ("MISSED," + String(currentSlot)).c_str());
        missedCount++;
        if (!cycleCompleted && (dispensedCount + missedCount >= MED_SLOTS)) {
          cycleCompleted = true;
        }
      }
      return;
    }

    // Send log only, no motor, no buzzer
    String logMsg = "PRESENCE_" + msg;
    mqttClient.publish("YOUR_TOPIC_STATUS", logMsg.c_str());

    return;
  }

  // ===== TIMER RECEIVED FROM DASHBOARD =====
schedHour = hh;
schedMinute = mm;
schedSecond = ss;
sprintf(ackMsg, "%d,%02d:%02d:%02d",
        currentSlot, schedHour, schedMinute, schedSecond);
mqttClient.publish("dispenser/1/schedule_ack", ackMsg);
scheduleActive = true;
  if (String(topic) == TOPIC_SET_TIME) {

    int hh = msg.substring(0, 2).toInt();
    int mm = msg.substring(3, 5).toInt();
    int ss = msg.substring(6, 8).toInt();

    schedHour = hh;
    schedMinute = mm;
    schedSecond = ss;

    // ---- SLOT ASSIGNMENT ----
    if (currentSlot < 7) {
      currentSlot++;
    } else {
      mqttClient.publish("YOUR_TOPIC_STATUS", "LAST_SLOT_REACHED");
      return;
    }

    // ---- ACK TO DASHBOARD ----
    char ackMsg[20];
    sprintf(ackMsg, "%d,%02d:%02d:%02d",
            currentSlot, schedHour, schedMinute, schedSecond);
    mqttClient.publish("YOUR_TOPIC_SCHEDULE_ACK", ackMsg);

    scheduleActive = true;

  }
}

// -------------------------------------------
// MQTT CONNECTION
// -------------------------------------------
void connectMQTT() {
  while (!mqttClient.connected()) {
    Serial.println("Connecting to MQTT...");

    if (mqttClient.connect("ESP32_Dispenser", MQTT_USER, MQTT_PASS)) {
      Serial.println("MQTT CONNECTED!");


      mqttClient.subscribe(TOPIC_AI_RESULT);
      mqttClient.subscribe(TOPIC_SET_TIME);
      mqttClient.subscribe("YOUR_TOPIC_MANUAL");

      mqttClient.publish("YOUR_TOPIC_STATUS", "ONLINE");

    } else {
      Serial.print("Failed. State=");
      Serial.println(mqttClient.state());
      delay(1500);
    }
  }
}

// -------------------------------------------
// SETUP
// -------------------------------------------
void setup() {
  Serial.begin(115200);
  
  // LCD
  Wire.begin(21, 22);
  lcd.init();
  lcd.backlight();
  printCentered(0, "Starting...");
  delay(700);

  // RTC
  if (!rtc.begin()) {
    printCentered(0, "RTC ERROR");
    while (1);
  }

  // Stepper
  stepper.setMaxSpeed(700);
  stepper.setAcceleration(350);
  stepper.setSpeed(500);

  // Buzzer
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  // WiFi
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  printCentered(0, "WiFi Connecting");

  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
  }

  printCentered(0, "WiFi Connected");
  delay(500);

  syncRTCWithNTP();

  // MQTT
  wifiClient.setInsecure();
  mqttClient.setServer(MQTT_BROKER, MQTT_PORT);
  mqttClient.setCallback(mqttCallback);
  connectMQTT();

  lcd.clear();
}

// -------------------------------------------
// SYNC RTC TIME
// -------------------------------------------
void syncRTCWithNTP() {

  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);

  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain NTP time");
    return;
  }

  Serial.println("NTP time obtained, syncing RTC...");

  rtc.adjust(DateTime(
    timeinfo.tm_year + 1900,
    timeinfo.tm_mon + 1,
    timeinfo.tm_mday,
    timeinfo.tm_hour,
    timeinfo.tm_min,
    timeinfo.tm_sec
  ));

  Serial.println("RTC synced with NTP");
}

// -------------------------------------------
// MAIN LOOP
// -------------------------------------------
void loop() {

  if (!mqttClient.connected()) connectMQTT();
  mqttClient.loop();

  DateTime now = rtc.now();

  // LCD override handling
  if (lcdOverride) {
    if (millis() - lcdOverrideStart > LCD_OVERRIDE_DURATION) {
    lcdOverride = false;
    lcd.clear();
  }
}

// Update display
if (!lcdOverride) {
  char timeBuf[9];
  sprintf(timeBuf, "%02d:%02d:%02d", now.hour(), now.minute(), now.second());
  printCentered(0, timeBuf);

  char dateBuf[11];
  sprintf(dateBuf, "%02d/%02d/%04d", now.day(), now.month(), now.year());
  if (!motorMoving) printCentered(1, dateBuf);
}

  // Stepper movement
  if (stepper.distanceToGo() != 0) {
    stepper.run();
  } else if (motorMoving) {
    motorMoving = false;
    alarmActive = false;
    digitalWrite(BUZZER_PIN, LOW);

    checkRefillStatus();
  }

  if (homingPending && !motorMoving) {
    if (millis() - homingStartTime >= HOME_DELAY_MS) {

        long stepsBack = physicalSlotIndex  * STEPS_PER_SLOT;

        if (stepsBack > 0) {
            stepper.move(-stepsBack);   // rotate back to HOME
            motorMoving = true;
        }

        // Reset slot tracking
        currentSlot = 0;
        physicalSlotIndex = 0;
        homingPending = false;

        Serial.println("AUTO HOME: Returned to slot 0");
        mqttClient.publish("YOUR_TOPIC_STATUS", "HOME_RETURNED");
    }
}
  // ----------------------------
  // TIMER LOGIC
  // ----------------------------
  if (scheduleActive) {

    // Mode 2 — INTERVAL MODE
    if (intervalMode) {
      if (millis() - lastIntervalTime >= (unsigned long)schedSecond * 1000) {
        Serial.println("INTERVAL HIT → ALARM_TRIGGERED");
        aiTriggeredByTimer = true;  
        mqttClient.publish(TOPIC_ALERT, "ALARM_TRIGGERED");
        alarmActive = true;
        lastIntervalTime = millis();
      }
    }

    // Mode 1 — ABSOLUTE TIME
    else {
      if (now.hour() == schedHour &&
          now.minute() == schedMinute &&
          now.second() == schedSecond) {

        Serial.println("TIME MATCH → ALARM_TRIGGERED");
        aiTriggeredByTimer = true;  
        mqttClient.publish(TOPIC_ALERT, "ALARM_TRIGGERED");
        alarmActive = true;

        scheduleActive = false;  // one-time trigger
      }
    }
  }

  // Alarm buzzer
  if (alarmActive) {
    if (millis() % 800 < 300) digitalWrite(BUZZER_PIN, HIGH);
    else                      digitalWrite(BUZZER_PIN, LOW);
  }

  if (cycleCompleted) {
  printCycleSummary();      // Serial + MQTT summary
  checkRefillStatus();      // Existing refill logic
  homingPending = true;
  homingStartTime = millis();

  // Reset for next cycle
  dispensedCount = 0;
  missedCount = 0;
  cycleCompleted = false;

  Serial.println("System reset for next cycle");
}
}
void printCycleSummary() {
  Serial.println("===== CYCLE COMPLETE =====");
  Serial.print("Dispensed: ");
  Serial.println(dispensedCount);
  Serial.print("Missed: ");
  Serial.println(missedCount);

  // Publish summary via MQTT (single message)
  String summary = "CYCLE_COMPLETE," +
                   String(dispensedCount) + "," +
                   String(missedCount);

  mqttClient.publish("YOUR_TOPIC_CYCLE_SUMMARY", summary.c_str());
}


